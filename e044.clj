
;  Pentagonal numbers are generated by the formula, Pn=n(3n1)/2. The first ten pentagonal numbers are:
;  1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
;  It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70  22 = 48, is not pentagonal.
;  Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference is pentagonal and D = |Pk  Pj| is minimised; what is the value of D?

(defn calc-pentagonal [n]
  "Calcs the nth pentagonal number."
  (/ (* n (- (* 3 n) 1)) 2))

(Math/floor 12.3)

(defn find-pentagonal-index [number]
  "For given fractional number finds an adequate pentagonal number.
  Runs the result through given transformer function."
  (/ (+ 1 (Math/sqrt (+ (* 24 number) 1)) )6))
(assert (= (Math/floor (find-pentagonal-index 12.5)) 3))
(assert (= (Math/floor (find-pentagonal-index 1.2)) 1))
(assert (= (Math/ceil (find-pentagonal-index 51.7)) 7))

(defn gen-pentagonals-in-interval [low high]
  "Generates all the pentagonals numbers within the closed interval."
  (let [low-index (Math/ceil (find-pentagonal-index low))
        high-index (Math/floor (find-pentagonal-index high))]
    (for [n (range low-index (inc high-index))]
      (calc-pentagonal n))))

(defn is-pentagonal? [number]
  "Checks whether a given number is pentagonal."
  (let [index (find-pentagonal-index number)]
  (= (Math/floor index) index)))
(assert (= (is-pentagonal? 1) true))
(assert (= (is-pentagonal? 12) true))
(assert (= (is-pentagonal? 35) true))
(assert (= (is-pentagonal? 143) false))
(assert (= (is-pentagonal? 60) false))

(defn calc-low-high [sum diff]
  (let [low (/ (- sum diff) 2)
        high (+ low diff)]
    [low high]))

(defn check-pentagonals [sum diff]
  "For given sum finds pentagonal numbers with required properties about sum and diff.
   If there are no such numbers returns (nil, nil)."
  (let [[low high] (calc-low-high sum diff)]
    (if (and (is-pentagonal? low) (is-pentagonal? high))
      true
      false)))

(defn find-min-pentagonal-pair []
  (loop [index 3 best nil initial [1 5]]
    (let [pentagonal (calc-pentagonal index)
          potential-diffs
            (if (nil? best)
              initial
              (let [[low high] (calc-low-high pentagonal best)]
                (gen-pentagonals-in-interval low high)))
          new-best
            (reduce
              #(if (and (or (nil? %1)
                            (< %2 %1))
                        (check-pentagonals pentagonal %2))
                 (do
                   (println %2 index)
                   %2)
                 %1) best potential-diffs)]
      ; print some status
      (if (< (count potential-diffs) 2)
        (do
          (println "steps" index)
        best)
        (recur (inc index) new-best (conj initial pentagonal))))))
(println (find-min-pentagonal-pair))

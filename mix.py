# -*- coding: utf-8 -*-

import math
import elib
import debug
import itertools

import psyco
psyco.full()

def problem_1():

    def three_five_seed(l):
        three_multis = filter(lambda x: x % 3 == 0, l)
        five_multis = filter(lambda x: x % 5 == 0, l)
        return list(set(three_multis + five_multis))


    return sum(three_five_seed(xrange(1000)))

def problem_2():

    return sum(elib.conditioned_generator(elib.filtered_generator(elib.fib(), lambda x: x % 2 == 0), lambda x: x < 4000000))

def problem_3():
    """
    The prime factors of 13195 are 5, 7, 13 and 29.
    What is the largest prime factor of the number 600851475143 ?
    """

    return elib.prime_factors(600851475143)

def problem_4():
    """
    A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.
    Find the largest palindrome made from the product of two 3-digit numbers.
    """

    return max(filter(elib.is_palindrome, list(map(lambda d: d[0] * d[1], elib.doubles_from_to(100, 999)))))

def problem_10():
    """
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
    Find the sum of all the primes below two million.
    """

    return sum(elib.primes_to(2000000))

def problem_12():
    """
    The sequence of triangle numbers is generated by adding the natural numbers. 
    So the 7^(th) triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    Let us list the factors of the first seven triangle numbers:

         1: 1
         3: 1,3
         6: 1,2,3,6
        10: 1,2,5,10
        15: 1,3,5,15
        21: 1,3,7,21
        28: 1,2,4,7,14,28

    We can see that 28 is the first triangle number to have over five divisors.

    What is the value of the first triangle number to have over five hundred divisors?
    """

    i = 1 
    t = 0

    while True:
        d = len(elib.divisors(t))
        if len(elib.divisors(t)) > 500:
            return t
        t += i
        i += 1

def problem_16():
    """
    2^(15) = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
    What is the sum of the digits of the number 2^(1000)?
    """
    return sum(map(int, list(str(2**1000))))

def problem_20():
    """
    n! means n * (n - 1) * ... * 3 * 2 * 1
    Find the sum of the digits in the number 100!
    """
    return sum(map(int, list(str(math.factorial(100)))))

def problem_13():
    """
    Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
    """
    numbers = elib.load_numbers('data/14.txt', split=True)
    total = sum(numbers)

    return str(total)[:10]

def problem_11():
    """
    What is the greatest product of four adjacent numbers in any direction (up, down, left, right, or diagonally) in 
    the given 20x20 grid?
    """
    numbers = elib.load_numbers('data/15.txt', split=True)
    size = int(math.sqrt(len(numbers)))
    seq_len = 4
    max = 0
    direction = {
            'up':         (lambda x: x > size, -size),
            'down':       (lambda x: x < size**2 - size, -size),
            'left':       (lambda x: x % size != 0, -1),
            'right':      (lambda x: x % size != size - 1, +1),
            'diag_right': (lambda x: x < size**2 - size and x % size != size - 1, size + 1),
            'diag_left':  (lambda x: x < size**2 - size and x % size != 0, size - 1)
           }

    for i in xrange(len(numbers)):
        for d in direction.values():
            pos = i
            act = numbers[pos]
           # ids = [i]
            for j in xrange(seq_len - 1):
                if not d[0](pos):
                    break
                pos += d[1]
                act *= numbers[pos]
            if act > max:
                max = act

    return max

def problem_14():
    """
    The following iterative sequence is defined for the set of positive integers:

        n -> n/2 (n is even)
        n -> 3n + 1 (n is odd)

        Using the rule above and starting with 13, we generate the following sequence:
            13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1

            It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. 
            Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

            Which starting number, under one million, produces the longest chain?

            NOTE: Once the chain starts the terms are allowed to go above one million.
    """

    best = 0
    best_len = 0
    tt = {}

    for i in xrange(1, 1000000):
        chain_len = 1
        act = i

        while True:
            if act in tt:
                chain_len += tt[act]
                break

            if act == 1:
                break

            if act % 2 == 0:
                act /= 2
            else:
                act = 3*act + 1
            chain_len += 1
        tt[i] = chain_len

        if chain_len > best_len:
            best = i
            best_len = chain_len

    return best

def problem_25():
    """
    F1 = 1 
    F2 = 1
    F3 = 2 
    ...
    What is the first term in the Fibonacci sequence to contain 1000 digits?
    """
    i = 0
    for f in elib.fib():
        i += 1
        if (len(str(f)) >= 1000):
            return i

def problem_48():
    """
    The series, 1^(1) + 2^(2) + 3^(3) + ... + 10^(10) = 10405071317.

    Find the last ten digits of the series, 1^(1) + 2^(2) + 3^(3) + ... + 1000^(1000).
    """

    act = 0
    m = 10 ** 10 
    for i in xrange(1, 1000):
        act += elib.last_n_power(i, i, 10)
        act %= m
    return act

def problem_18_67(fn):
    """
    By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.

        3
       7 5
      2 4 6
     8 5 9 3

    That is, 3 + 7 + 4 + 9 = 23.
    """
    triangle = open(fn,'r').readlines()
    triangle = map(lambda x: x.strip(), triangle)
    triangle = map(lambda x: x.split(), triangle)

    #triangle format check + int convertion
    for i in range(0, len(triangle)):
        if len(triangle[i]) != i + 1: 
            raise Exception("wrong data format")
        triangle[i] = map(int, triangle[i])
    if len(triangle) < 1: 
        raise Exception("wrong data format")

    #we go from bottom
    triangle.reverse()
    #last line is identity
    sums = triangle[0]
    for i in xrange(1, len(triangle)):
        new_sums = []
        line = triangle[i]
        for j in xrange(len(line)):
            new_sums.append(line[j] + max(sums[j], sums[j+1]))
        sums = new_sums 
    return new_sums[0] 

def problem_18():
    return problem_18_67('data/18.txt')

def problem_67():
    return problem_18_67('data/67.txt')

def problem_21():
    """
    Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
    If d(a) = b and d(b) = a, where a != b, then a and b are an amicable pair and each of a and b are called amicable numbers.

    For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1,
    2, 4, 71 and 142; so d(284) = 220.

    Evaluate the sum of all the amicable numbers under 10000.
    """

    admicables = [] 
    for i in xrange(1, 10000):
        di  = sum(elib.divisors(i)[:-1])
        if i == di:
            continue
        dii = sum(elib.divisors(di)[:-1])
        if i == dii:
            admicables.append(i)
            admicables.append(di)
        
    return sum(set(admicables))
        
def problem_28():
    """
    Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:

    21 22 23 24 25
    20  7  8  9 10
    19  6  1  2 11
    18  5  4  3 12
    17 16 15 14 13

    It can be verified that the sum of the numbers on the diagonals is 101.

    What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
    """

    elem = 1
    step = 2
    corner = 0
    sum = 1
    while step < 1000 or corner != 4:
        if corner == 4:
            step += 2
            corner = 0
        elem += step
        sum += elem 
        corner += 1

    return sum

def problem_31(): 
    """
    In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:
    1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
    It is possible to make £2 in the following way:
        1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
    How many different ways can £2 be made using any number of coins?
    """

    coins = (200, 100, 50, 20, 10, 5, 2, 1)
    used = [0] * len(coins)
    goal = 200
    solutions = 0
    act = 0
    while True:

        if coins[act] > goal and act < len(used):
            act += 1
            continue
             
        if coins[act] <= goal:
            #TODO shortcut for last coin
            #go forward
            goal -= coins[act]
            used[act] += 1
            if goal == 0:
                solutions += 1
            else:
                continue

        #Either has a solution or figures that there cannot be one
        #stopping criteria
        if sum(used) == used[-1]:
            print "found %s solutions" % solutions
            break
        #backtracking
        goal += used[-1] * coins[-1]
        used[-1] = 0
        for i in reversed(range(0, len(used))):
            if used[i]:
                act = i + 1
                used[i] -= 1
                goal += coins[i]
                break

def problem_32():
    """
    We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; 
    for example, the 5-digit number, 15234, is 1 through 5 pandigital. 
    The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, 
    and product is 1 through 9 pandigital.
    
    Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 
    pandigital. HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.
    """

    def _get_numbers(digits, indexes):
        res = []
        for l, r in indexes:
            res.append(elib.horner(digits[l:r]))
        return res
              

    patterns = [((0,4), (4, 7), (7, 9)),
                ((0,4), (4, 8), (8, 9))]
    
    pandig = set([])
    for perm in elib.perm_gen(range(1, 10)):
        for pattern in patterns:
            r, mr, mt = _get_numbers(perm, pattern)
            if r == mr * mt:
                print r, mr, mt
                pandig.add(r)
    print pandig, sum(pandig)

def problem_35():
    """
    The number, 197, is called a circular prime because all rotations of the digits: 
        197, 971, and 719, are themselves prime.
    There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
    How many circular primes are there below one million?
    """

    primes = set(elib.primes_to(1000000))
    circulars = 0
    for prime in primes:
        is_circular = True
        for rotation in elib.digit_rotator(prime): 
            if rotation not in primes: 
                is_circular = False
                break

        if is_circular:
            circulars += 1

    return circulars

def problem_62():
    """
    The cube, 41063625 (345^(3)), can be permuted to produce two other cubes: 
    56623104 (384^(3)) and 66430125 (405^(3)). In fact, 41063625 is the
    smallest cube which has exactly three permutations of its digits which are also cube.
    Find the smallest cube for which exactly five permutations of its digits are cube.
    """
    cubes = {}
    i = 0
    while True:
        cube = i**3
        hash = tuple(sorted(str(cube)))
        if hash in cubes:
            cubes[hash] = (cubes[hash][0], cubes[hash][1] + 1)
            if cubes[hash][1] == 5:
                print cubes[hash][0] 
                break
        else:
            cubes[hash] = (cube, 1)
        i += 1 


if __name__ == '__main__':
    import sys
    try:
        n = int(sys.argv[1])
        with debug.Timer():
            print "Answer to problem %d is" % n, globals()['problem_%d' % n]()
    except: 
        pass

